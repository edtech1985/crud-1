import React, { useEffect, useState } from "react";
import {
  Box,
  Typography,
  Grid,
  Paper,
  Avatar,
  Slide,
  Select,
  MenuItem,
  SelectChangeEvent,
  IconButton,
  Stack,
  InputLabel,
  FormControl,
  Fab,
  Tooltip,
  Chip,
  Button,
} from "@mui/material";
import TuneIcon from "@mui/icons-material/Tune";
import WhatsAppIcon from "@mui/icons-material/WhatsApp";
import modelsData from "../../db/models-details.json";
import ImageBox from "../../components/ImageBox";
import useScrollTrigger from "@mui/material/useScrollTrigger";
import KeyboardArrowUpIcon from "@mui/icons-material/KeyboardArrowUp";
import Fade from "@mui/material/Fade";
import Snackbar, { SnackbarOrigin } from "@mui/material/Snackbar";
import { Model } from "../../types";
import {
  BustTooltip,
  UnverifiedTooltip,
  VerifiedTooltip,
  WhatsappTooltip,
} from "../../components/Tooltips";
import { NewReleases, Verified } from "@mui/icons-material";
import Loading from "../../components/Loading";
import LocationOnIcon from "@mui/icons-material/LocationOn";
import { useParams } from "react-router-dom";
 import FavoriteIcon from "@mui/icons-material/Favorite";

interface Filters {
  modelType:
    | "loiras"
    | "morenas"
    | "ruivas"
    | "orientais"
    | "negras"
    | "mulatas"
    | "duplas"
    | "indiferente"
    | "";
  showFace: "sim" | "não" | "indiferente";
  alturaMin?: string;
  alturaMax?: string;
}

interface State extends SnackbarOrigin {
  open: boolean;
}

interface Props {
  window?: () => Window;
  children: React.ReactElement;
}

const MenuItemStyles = {
  bgcolor: "black",
  color: "gold",
};

// === === === BEGIN SCROLL TO TOP === === === //
function ScrollTop(props: Props) {
  const { children, window } = props;
  const trigger = useScrollTrigger({
    target: window ? window() : undefined,
    disableHysteresis: true,
    threshold: 100,
  });

  const handleClick = (event: React.MouseEvent<HTMLDivElement>) => {
    const anchor = (
      (event.target as HTMLDivElement).ownerDocument || document
    ).querySelector("#back-to-top-anchor");

    if (anchor) {
      anchor.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    }
  };

  return (
    <Fade in={trigger}>
      <Box onClick={handleClick} role="presentation" sx={{ zIndex: 9999 }}>
        {children}
      </Box>
    </Fade>
  );
}
// === === === END SCROLL TO TOP === === === //

export default function Models() {
  const [favorites, setFavorites] = useState<number[]>([]);
  const [selectedModel, setSelectedModel] = useState<Model | null>(null);
  const [snackbarStates, setSnackbarStates] = useState<{
    [key: number]: boolean;
  }>({});
  const [filterOpen, setFilterOpen] = useState(false);
  const [filters, setFilters] = useState<Filters>({
    modelType: "indiferente",
    showFace: "indiferente",
  });
  const [loading, setLoading] = useState(true);
  const [models, setModels] = useState<Model[]>([]);
  const { estado, cidade } = useParams<{ estado: string; cidade: string }>();

  // Filtrar as modelos com base no estado e na cidade
  useEffect(() => {
    const filteredModels = modelsData.filter((model) => {
      if (model.hasLocation) {
        return (
          model.localInfo.state.toLowerCase() === estado?.toLowerCase() &&
          model.localInfo.city.toLowerCase() === cidade?.toLowerCase()
        );
      } else {
        return false;
      }
    });

    setModels(filteredModels);
    setLoading(false); // Finaliza o estado de carregamento após definir os modelos
  }, [estado, cidade]);

  // === === === BEGIN MOUSE ENTER AND LEAVE === === === //
  const handleMouseEnter = (model: Model) => {
    setSelectedModel(model);
  };

  const handleMouseLeave = () => {
    setSelectedModel(null);
  };
  // === === === END MOUSE ENTER AND LEAVE === === === //

  // === === === BEGIN SNACKBAR === === === //
  const [state] = React.useState<State>({
    open: false,
    vertical: "top",
    horizontal: "center",
  });

  const { vertical, horizontal } = state;

  const handleSnackbar = (modelId: number) => {
    setSnackbarStates((prevState) => ({
      ...prevState,
      [modelId]: true,
    }));
  };

  const handleClose = (modelId: number) => {
    setSnackbarStates((prevState) => ({
      ...prevState,
      [modelId]: false,
    }));
  };
  // === === === END SNACKBAR === === === //

  // === === === BEGIN FAVORITES === === === //
  useEffect(() => {
    const storedFavorites = localStorage.getItem("favorites");
    if (storedFavorites) {
      setFavorites(JSON.parse(storedFavorites));
    }
    const timer = setTimeout(() => {
      setLoading(false);
    }, 1500);

    return () => clearTimeout(timer);
  }, []);

  const handleFavoriteToggle = (modelId: number) => {
    let updatedFavorites: number[] = [];
    if (favorites.includes(modelId)) {
      updatedFavorites = favorites.filter((id) => id !== modelId);
    } else {
      updatedFavorites = [...favorites, modelId];
    }
    setFavorites(updatedFavorites);
    localStorage.setItem("favorites", JSON.stringify(updatedFavorites));
  };
  // === === === END FAVORITES === === === //

  // === === === BEGIN FILTERING === === === //
  const handleFilterChange = (value: string, filterName: keyof Filters) => {
    setFilters((prevFilters) => ({
      ...prevFilters,
      [filterName]: value,
    }));
  };

  const handlemodelTypeChange = (
    e: SelectChangeEvent<
      | "loiras"
      | "morenas"
      | "ruivas"
      | "orientais"
      | "negras"
      | "mulatas"
      | "duplas"
      | "indiferente"
    >
  ) => {
    handleFilterChange(e.target.value, "modelType");
  };

  const handleshowFaceChange = (
    e: SelectChangeEvent<"sim" | "não" | "indiferente">
  ) => {
    handleFilterChange(e.target.value, "showFace");
  };

  const filteredModels = models.filter((model) => {
    if (
      filters.modelType !== "indiferente" &&
      model.modelType !== filters.modelType
    ) {
      return false;
    }
    if (
      filters.showFace !== "indiferente" &&
      model.showFace !== filters.showFace
    ) {
      return false;
    }
    return true;
  });

  const clearFilters = () => {
    setFilters({
      modelType: "indiferente",
      showFace: "indiferente",
    });
  };

  const totalModelsInCity = models.length;
  // === === === END FILTERING === === === //

  return (
    <Box textAlign="center">
      {loading && <Loading />}
      <div id="back-to-top-anchor" />
      <Box id="page-description" mb={2}>
        <Typography variant="h4" component="h1" gutterBottom>
          Nossas Modelos
        </Typography>

        {cidade && (
          <Typography variant="body1">
            {totalModelsInCity} modelos disponíveis em {cidade}
          </Typography>
        )}
        {(filters.modelType !== "indiferente" ||
          filters.showFace !== "indiferente") && (
          <Box display="inline">
            {filters.modelType !== "indiferente" && (
              <Typography variant="body1" display="inline">
                {
                  filteredModels.filter(
                    (model) => model.modelType === filters.modelType
                  ).length
                }{" "}
                modelos {filters.modelType}{" "}
              </Typography>
            )}
            {filters.showFace !== "indiferente" && (
              <Typography variant="body1" display="inline">
                {
                  filteredModels.filter(
                    (model) => model.showFace === filters.showFace
                  ).length
                }{" "}
                que mostram o rosto
              </Typography>
            )}
          </Box>
        )}
      </Box>

      <Button variant="contained" color="primary" onClick={clearFilters}>
        Limpar Filtros
      </Button>

      <Grid container spacing={4}>
        {filteredModels.map((model) => (
          <Grid item xs={12} sm={6} md={4} key={model.id}>
            <Paper
              elevation={3}
              sx={{ padding: 2, textAlign: "center", position: "relative" }}
              onMouseEnter={() => handleMouseEnter(model)}
              onMouseLeave={handleMouseLeave}
            >
              <Avatar
                alt={model.name}
                src={model.avatar}
                sx={{
                  width: 150,
                  height: 150,
                  margin: "0 auto",
                  marginBottom: 2,
                }}
              />
              <Typography variant="h6">{model.name}</Typography>
              <Typography variant="body2" color="textSecondary">
                {model.description}
              </Typography>
              <Box mt={2}>
                <Chip
                  icon={<LocationOnIcon />}
                  label={`${model.localInfo.city}, ${model.localInfo.state}`}
                />
              </Box>
              {model.hasVideoVerification === true ? (
                <Box
                  sx={{
                    width: "fit-content",
                    borderRadius: "16px",
                  }}
                >
                  <VerifiedTooltip
                    title="Esta modelo enviou o vídeo de verificação a menos de 6 meses."
                    TransitionComponent={Fade}
                    TransitionProps={{ timeout: 700 }}
                    placement="top"
                    arrow
                  >
                    <Chip
                      label="Verified"
                      size="small"
                      icon={<Verified />}
                      color="success"
                      sx={{
                        "&:hover": {
                          bgcolor: "green",
                        },
                      }}
                    />
                  </VerifiedTooltip>
                </Box>
              ) : (
                <Box
                  sx={{
                    width: "fit-content",
                    borderRadius: "16px",
                  }}
                >
                  <UnverifiedTooltip
                    title="Esta modelo ainda não enviou o vídeo de verificação."
                    TransitionComponent={Fade}
                    TransitionProps={{ timeout: 700 }}
                    placement="top"
                    arrow
                  >
                    <Chip
                      label="Unverified"
                      size="small"
                      icon={<NewReleases />}
                      color="error"
                      sx={{
                        "&:hover": {
                          bgcolor: "red",
                        },
                      }}
                    />
                  </UnverifiedTooltip>
                </Box>
              )}
              <Tooltip title="Adicionar aos favoritos">
                <IconButton
                  color={favorites.includes(model.id) ? "primary" : "default"}
                  onClick={() => handleFavoriteToggle(model.id)}
                >
                  <FavoriteIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="Enviar mensagem pelo WhatsApp">
                <IconButton
                  color="success"
                  onClick={() => handleSnackbar(model.id)}
                >
                  <WhatsAppIcon />
                </IconButton>
              </Tooltip>
              <Snackbar
                anchorOrigin={{ vertical, horizontal }}
                open={snackbarStates[model.id]}
                onClose={() => handleClose(model.id)}
                message={`Mensagem para ${model.name}`}
                key={model.id}
              />
            </Paper>
          </Grid>
        ))}
      </Grid>

      <ScrollTop>
        <Tooltip title="Voltar ao topo" arrow>
          <Fab
            size="small"
            aria-label="scroll back to top"
            sx={{
              position: "fixed",
              bottom: 16,
              right: 16,
              zIndex: 9999,
              opacity: 0.4,
              transition: "opacity 0.5s ease",
              "&:hover": {
                opacity: 1,
              },
            }}
          >
            <KeyboardArrowUpIcon />
          </Fab>
        </Tooltip>
      </ScrollTop>
    </Box>
  );
}
